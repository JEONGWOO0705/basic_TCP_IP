# basic_TCP_IP
IoT 개발자과정 TCP/IP 학습 리포지토리



## 1일차
- 네트워크 프로그래밍
    - 소켓을 기반으로 프로그래밍을 하기 때문에 소켓 프로그래밍이라고 한다
    - 네트워크로 연결된 둘 이상의 컴퓨터 사이에서의 데이터 송수신 프로그램의 작성

- 소켓에 대한 간단한 이해
    - 네크워트(인터넷)의 연결도구
    - 운영체제에 의해 제공이 되는 소프트웨어적인 장치
    - 소켓은 프로그래머에게 데이터 송수신에 대한 물리적, 소프트웨어적 세세한 내용을 신경안씀!
- TCP/IP 확인하는 법 : cmd -> ipconfig
- 전송 방식 
    - TCP
    - UDP

- 소켓(socket)
- 바인더(bind)
- 리슨(listen)
- 엑셉트(accept)

- 프로토콜
    - 컴퓨터 상호간의 데이터 송수신에 필요한 통신 규약
    - 소켓을 생성할때 기본적인 프로토콜을 지정해야한다.
    - 프로토콜 체계
        - PF_INET은 IPv4 인터넷 프로토콜 체계

- 소켓의 타입
    - 데이터 전송방식을 의미
    - 소켓이 생성될때 소켓의 타입도 결정해야함
    - 프로토콜 체계 PF_INET 의 대표적인 소켓 타입 두개
        - 연결지향형 소켓(TCP 소켓)
            - 중간에 데이터 소멸되지 않음
            - 전송 순서대로 데이터가 수신
            - 데이터 경계가 존재하지 않음
            - 소켓대 소켓의 연결은 반드시 1대1
        - 비 연결 지향형 소켓(UDP 소켓)
            - 전송 순서 상관없이 빠른 속도의 전송을 지향
            - 데이터 손실 우려
            - 데이터 경계 존재
            - 한번에 전송할 수 있는 데이터 크기가 제한

            ```c
            int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);//TCP

            int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);//UDP
            ```
- 소켓에 할당되는 IP주소와 PORT번호
    - 인터넷 주소란
        - 컴퓨터를 구분하는 목적으로 사용되는 주소
        - 4바이트 IPv4, 16바이트 IPv6
        - 소켓을 생성할때 기본적인 프로토콜을 지정해야한다.
        - 네트워크 주소와 호스트 주소로 나뉨. 네트워크 주소를 이용해서 네트워크 찾고, 호스트 주소를 통해 호스트 구분 

    - PORT 번호
        - IP는 컴퓨터를 구분하는 용도로 사용되며, PORT번호는 소켓을 구분하는 용도로 사용
        - 하나의 프로그램 내에서 둘 이상의 소켓이 존재할 수 있으므로, 둘이상의 PORT가 하나의 프로그램에 할당 될 수 있음
        - PORT번호는 16비트로 표현, 따라서 그 값은 0 이상 65535 이하

    - IPv4 기반의 주소 표현을 위한 구조
        - sin_family : 주소체계 정보 저장
        - sin_port : 16비트 PORT번호 저장
        - sin_addr : 32비트 IP주소 저장


    ```c
    struct sockaddr_in{
        sa_family_t sin_family; // 주소 체계 
        uint16_t sin_port; // PORT 번호
        struct in_addr sin_addr; // 32비트 IP주소
        
    }
    ```
    - 네트워크 바이트 순서와 인터넷 주소 변환
        - 빅엔디안, 리틀엔디안
        - htons에서 h는 호스트 바이트 순서 , n은 네트워크 바이트 순서를 의미한다
        - s는 short, l은 long 
        - --->>> h, to, n , s의 조합으로 해석
        - 변환과정은 자동으로 이루어짐. sockaddr_in 구조체 변수에 데이터를 채울때 이외에는 바이트 순서를 신경쓰지 않아도된다!!

    - 문자열 정보를 네트워크 바이트 순서의 정수로 변환하기
        - IP 주소를 표현할때 "211.214.107.99" 와같이 십진수 표현방식에 익숙
        - but 이것을 32비트로 변환해야함. -> 이것을 해결해주는 함수가 있다.
        - inet_addr(const char*string) , inet_aton(const char* string, struct in_addr * addr);!!! 2가지이다.
        - 이 함수는 32비트 정수형태로 IP주소를 변환할 뿐만 아니라, 유효하지 않은 IP주소에 대한 오류 검출 능력도 있다!!
        - day01 >> inet_addr.c 파일 !!

        - inet_ntoa : inet-aton함수의 반대기능 제공!!, 네트워크 바이트 순서로 정렬된 정수형 IP주소 정보를 우리가 눈으로 쉽게 인식할 수 있는 문자열의 형태로 변환

## 2일차

- TCP 기반 서버/ 클라이언트 1
    1. TCP와 UDP에 대한 이해
        - TCP/IP 프로토콜 스택이란
            - 인터넷 기반의 데이터 송수신을 목적으로 설계된 스택
            - 큰 문제를 작게 나눠서 계층화한 결과
            - 데이터 송수신의 과정을 네개의 영역으로 계층화한 결과

        - LINK 계층의 기능
            - 물리적인 영역의 표준화 결과
            - LAN, WAN, MAN과 같은 물리적인 네트워크 표준관련 프로토콜이 정의된 영역

        - IP계층의 기능및 역할
            - IP는 Internet Protocol을 의미
            - 경로의 설정과 관련이 있는 프로토콜

        - TCP는 데이터의 전송을 보장(신뢰성), UDP는 보장하지 않는 프로토콜

    2. TCP기반 서버, 클리아언트의 구현
        - TCP서버의 기본적인 함수 호출 순서 (서버 입장)
            1. socket() 소켓생성
            2. bind() 소켓 주소 할당
            3. listen() 연결요청 대기상태
            4. accept() 연결허용
            5. read()/write() 데이터 송수신
            6. close() 연결 종류
        - bind 함수까지 호출이 되면 주소가 할당된 소켓을 얻게 된다
        - 따라서 listen함수의 호출을 통해서 연결요청이 가능한 상태가 되어야한다.

        - client 입장
            - socket() -> connect() -> read()/write() -> close
            - 클라이언트 소켓은 자동으로 생성된다.

    3. Iterative 기반의 서버, 클라이언트 구현