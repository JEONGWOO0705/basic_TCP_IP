# basic_TCP_IP
IoT 개발자과정 TCP/IP 학습 리포지토리



## 1일차
- 네트워크 프로그래밍
    - 소켓을 기반으로 프로그래밍을 하기 때문에 소켓 프로그래밍이라고 한다
    - 네트워크로 연결된 둘 이상의 컴퓨터 사이에서의 데이터 송수신 프로그램의 작성

- 소켓에 대한 간단한 이해
    - 네크워트(인터넷)의 연결도구
    - 운영체제에 의해 제공이 되는 소프트웨어적인 장치
    - 소켓은 프로그래머에게 데이터 송수신에 대한 물리적, 소프트웨어적 세세한 내용을 신경안씀!
- TCP/IP 확인하는 법 : cmd -> ipconfig
- 전송 방식 
    - TCP
    - UDP

- 소켓(socket)
- 바인더(bind)
- 리슨(listen)
- 엑셉트(accept)

- 프로토콜
    - 컴퓨터 상호간의 데이터 송수신에 필요한 통신 규약
    - 소켓을 생성할때 기본적인 프로토콜을 지정해야한다.
    - 프로토콜 체계
        - PF_INET은 IPv4 인터넷 프로토콜 체계

- 소켓의 타입
    - 데이터 전송방식을 의미
    - 소켓이 생성될때 소켓의 타입도 결정해야함
    - 프로토콜 체계 PF_INET 의 대표적인 소켓 타입 두개
        - 연결지향형 소켓(TCP 소켓)
            - 중간에 데이터 소멸되지 않음
            - 전송 순서대로 데이터가 수신
            - 데이터 경계가 존재하지 않음
            - 소켓대 소켓의 연결은 반드시 1대1
        - 비 연결 지향형 소켓(UDP 소켓)
            - 전송 순서 상관없이 빠른 속도의 전송을 지향
            - 데이터 손실 우려
            - 데이터 경계 존재
            - 한번에 전송할 수 있는 데이터 크기가 제한

            ```c
            int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);//TCP

            int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);//UDP
            ```
- 소켓에 할당되는 IP주소와 PORT번호
    - 인터넷 주소란
        - 컴퓨터를 구분하는 목적으로 사용되는 주소
        - 4바이트 IPv4, 16바이트 IPv6
        - 소켓을 생성할때 기본적인 프로토콜을 지정해야한다.
        - 네트워크 주소와 호스트 주소로 나뉨. 네트워크 주소를 이용해서 네트워크 찾고, 호스트 주소를 통해 호스트 구분 

    - PORT 번호
        - IP는 컴퓨터를 구분하는 용도로 사용되며, PORT번호는 소켓을 구분하는 용도로 사용
        - 하나의 프로그램 내에서 둘 이상의 소켓이 존재할 수 있으므로, 둘이상의 PORT가 하나의 프로그램에 할당 될 수 있음
        - PORT번호는 16비트로 표현, 따라서 그 값은 0 이상 65535 이하

    - IPv4 기반의 주소 표현을 위한 구조
        - sin_family : 주소체계 정보 저장
        - sin_port : 16비트 PORT번호 저장
        - sin_addr : 32비트 IP주소 저장


    ```c
    struct sockaddr_in{
        sa_family_t sin_family; // 주소 체계 
        uint16_t sin_port; // PORT 번호
        struct in_addr sin_addr; // 32비트 IP주소
        
    }
    ```
    - 네트워크 바이트 순서와 인터넷 주소 변환
        - 빅엔디안, 리틀엔디안
        - htons에서 h는 호스트 바이트 순서 , n은 네트워크 바이트 순서를 의미한다
        - s는 short, l은 long 
        - --->>> h, to, n , s의 조합으로 해석
        - 변환과정은 자동으로 이루어짐. sockaddr_in 구조체 변수에 데이터를 채울때 이외에는 바이트 순서를 신경쓰지 않아도된다!!

    - 문자열 정보를 네트워크 바이트 순서의 정수로 변환하기
        - IP 주소를 표현할때 "211.214.107.99" 와같이 십진수 표현방식에 익숙
        - but 이것을 32비트로 변환해야함. -> 이것을 해결해주는 함수가 있다.
        - inet_addr(const char*string) , inet_aton(const char* string, struct in_addr * addr);!!! 2가지이다.
        - 이 함수는 32비트 정수형태로 IP주소를 변환할 뿐만 아니라, 유효하지 않은 IP주소에 대한 오류 검출 능력도 있다!!
        - day01 >> inet_addr.c 파일 !!

        - inet_ntoa : inet-aton함수의 반대기능 제공!!, 네트워크 바이트 순서로 정렬된 정수형 IP주소 정보를 우리가 눈으로 쉽게 인식할 수 있는 문자열의 형태로 변환

## 2일차

- TCP 기반 서버/ 클라이언트 1
    1. TCP와 UDP에 대한 이해
        - TCP/IP 프로토콜 스택이란
            - 인터넷 기반의 데이터 송수신을 목적으로 설계된 스택
            - 큰 문제를 작게 나눠서 계층화한 결과
            - 데이터 송수신의 과정을 네개의 영역으로 계층화한 결과

        - LINK 계층의 기능
            - 물리적인 영역의 표준화 결과
            - LAN, WAN, MAN과 같은 물리적인 네트워크 표준관련 프로토콜이 정의된 영역

        - IP계층의 기능및 역할
            - IP는 Internet Protocol을 의미
            - 경로의 설정과 관련이 있는 프로토콜

        - TCP는 데이터의 전송을 보장(신뢰성), UDP는 보장하지 않는 프로토콜

    2. TCP기반 서버, 클리아언트의 구현
        - TCP서버의 기본적인 함수 호출 순서 (서버 입장)
            1. socket() 소켓생성
            2. bind() 소켓 주소 할당
            3. listen() 연결요청 대기상태
            4. accept() 연결허용
            5. read()/write() 데이터 송수신
            6. close() 연결 종류
        - bind 함수까지 호출이 되면 주소가 할당된 소켓을 얻게 된다
        - 따라서 listen함수의 호출을 통해서 연결요청이 가능한 상태가 되어야한다.

        - client 입장
            - socket() -> connect() -> read()/write() -> close
            - 클라이언트 소켓은 자동으로 생성된다.

    - TCP 기반 서버/ 클라이언트 2
        - 서버는 데이터의 경계를 구분하지 않고 수신된 데이터를 그대로 전송할 의무만 갖는다
        - TCP가 본디 데이터의 경계가 없는 프로토콜이므로, 두번의 write함수호출을 통해서 데이터를 전송을 하든, 세번의 write함수 호출을 통해 데이터를 전송하든 문제가 안됨

        - 반면 클라이언트는 문장 단위로 데이터를 송 수신 하기 떄문에, 데이터의 경계를 구분해야함 -> 문제 발생!!

        - wrtie 함수호출을 통해서 전송한 데이터의 길이만큼 읽어 들이기 위한 반복문의 삽입이 필요하다.

        - TCP  소켓에 존재하는 입출력 버퍼
            - 입출력 버퍼는 TCP 소켓 각각에 대해 별도로 존재한다.
            - 입출력 버허는 소켓 생성시 자동으로 생성
            - 소켓을 닫아도 출력 버퍼에 남아있는 데이터는 계속해서 전송이 이루어진다.
            - 소켓을 닫으면 입력버퍼에 남아있는 데이터는 소멸
            - 1대1 연결

        - UDP 소켓과 TCP 소켓의 데이터 송수신 비교
            - UDP 소켓은 SEQ, ACK와 같은 메시지 전달을 하지 않는다.
            - 연결의 설정과 해제의 과정도 존재하지 않는다.
            - 때문에 데이터 분실 및 손실의 위험이 있다.
            - 하지만 데이터 전송이 빠름!!
            - 안전성 보다 성능이 중요시 될때 UDP 사용
            - 1대1 연결 XX
            - 서버소켓과 클라이언트 소켓의 구분이 없다.
        
    - 소켓 종료 
        - close 및 closesocket 함수 기능
            - 소켓의 완전 소멸을 의미
            - 소켓이 소멸되므로 더이상의 입출력 불가
            - 상대방의 상태에 상관없이 일방적인 종료
            - 때문에 상대 호스트의 데이터 송수신이 아직 완료되지 않은 상황이라면 문제가 발생할수도 있음
            - 이러한 문제에 대안으로 Half-close 기법을 사용

        - Half-close
            - 종료를 원한다는 것은, 더이상 전송할 데이터가 존재하지 않는 상황
            - 따라서 출력 스트림은 종료를 시켜도 된다.
            - 다만 상대방도 종료를 원하는지 확인되지 않은 상황이므로, 출력 스트림은 종료시키지 않을 필요가 있다.
            - 때문에 Half-close라 하면 **입력스트림만 종료하는 것!!!!**\

    **sudo raspi-config 라즈베리파이 환경설정 하는 법**

    - 도메인네임  IP 주소
        - 도메인
            - IP를 대신하는 서버의 주소 ex)www.naver.com
            - 실제 접속에 사용되는 주소는 아니다. 이정보는 IP변환이 되어야 접속이 가능하다

        - DNS 서버  
            - 도메인 이름을 IP로 변환해주는 서버
            - DNS는 데이터 베이스 시스템
    - 도메인 이름을 이용해서 IP주소 얻어오기 : gethostbyname
    - IP 주소를 통해 도메인 정보 얻어오기 : gethostbyaddr
    - 소켓의 옵션 정보를 확인하는 함수 : getsockopt

- 멀티 프로세스 서버
    - 다중 접속 서버의 구현 방법들
        - 멀티 프로세스 기반 서버
        - 멀티 플렉싱 기반 서버
        - 멀티 쓰레딩 기반 서버

    - 프로세스
        - 간단하게는 실행 중인 프로그램을 의미
        - 실행중인 프로그램에 관련된 메모리, 리소스 등을 총칭하는 의미
        - 멀티 프로세스 운영체제는 둘 이상의 프로세스를 동시에 생성 가능
    - 프로세스 ID
        - 운영체제는 생성되는 모든 프로세스에 ID를 할당

    - fork함수의 호출을 통한 프로세스 생성
        - fork 함수가 호출되면 호출한 프로세스가 복사되어 fork 함수 호출 이후를 각각의 프로세스가 독립적으로 실행하게 된다.
        - fork 함수 호출 이후의 반환값은 부모 프로세스와 자식프로세스의 프로그램 흐름을 구분(반환값의 차를 통해!!)
        - fork 함수를 호출한 프로세스는 부모 프로세스
        - fork 함수의 호출을 통해서 생성된 프로세스는 자식 프로세스

    - 좀비 프로세스
        - 실행이 완료되었음에도 불구하고, 소멸되지 않은 프로세스
        - 생성 원인
            - 자식 프로세스가 종료되면서 반환하는 상태값이 부모 프로세스에게 전달되지 않으면 해당 프로세스는 소멸되지 않고 좀비가 된다.

        - 좀비 프로세스의 소멸
            - wait() 함수   
                - 자식프로세스가 종료되지 않은 상황에서는 반환하지 않고 블로킹 상태에 놓인다.
            - waitpid() 함수
                - wait 함수는 블로킹 상태에 놓이지만, waitpid 함수는 블로킹 상태에 놓이지 않게끔 할 수 있다.
## 3일차 
- 멀티 프로세스 
    - 시그널
        - 특정 상황이 되었을떄 운영체제가 프로세스에게 해당상황이 발생하였음을 알리는 일종의 메시지 --> EVENT 같은 역할

        - 시그널 등록
            - 톡정 상황에서 운영체제로부터 프로세스가 시그널을 받기 위해서는 해당 상황에 대해서 등록과정을 거쳐야한다.

- 프로세스간 통신의 기본 개념
    - 프로세스간 통신
        - 두 프로세스 사이에서의 데이터 전달
        - 두 프로세스 사이에서 데이터 전달이 가능할려면 함께 공유하는 메모리가 존재해야한다
    
    - 프로세스간 통신의 어려움
        - 모든 프로세스는 자신만의 메모리 공간을 독립적으로 구성한다.
        - 운영체제가 별도의 메모리 공간을 마련해줘야 프로세스간 통신이 가능!!
        
        - ex. int pipe(int filedes[2])
            - filedes[0] 은 데이터를 수신하는데 사용하는 파일 디스크립터, 즉 파이프의 출구
            - filedes[1] 은 데이터를 전송하는데 사용, 즉 파이프의 입구.